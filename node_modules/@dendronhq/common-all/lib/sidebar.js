"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSidebar = exports.parseSidebarConfig = exports.processSidebar = exports.DisabledSidebar = exports.DefaultSidebar = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("./utils");
const parse_1 = require("./parse");
const error_1 = require("./error");
const constants_1 = require("./constants");
const noteLiteral = parse_1.z.literal("note");
const autogeneratedLiteral = parse_1.z.literal("autogenerated");
const categoryLiteral = parse_1.z.literal("category");
const idSchema = parse_1.z.string();
const sidebarItemNote = parse_1.z.object({
    type: noteLiteral,
    id: idSchema,
    label: parse_1.z.string(),
});
const sidebarItemAutogenerated = parse_1.z.object({
    type: autogeneratedLiteral,
    id: idSchema,
});
const sidebarItemCategoryLinkNote = parse_1.z.object({
    type: noteLiteral,
    id: idSchema,
});
const sidebarItemCategoryLink = sidebarItemCategoryLinkNote;
const sidebarItemCategoryConfig = parse_1.z.lazy(() => parse_1.z
    .object({
    type: categoryLiteral,
    label: parse_1.z.string(),
    items: parse_1.z.array(parse_1.z.lazy(() => sidebarItemConfig)),
    link: sidebarItemCategoryLink,
})
    .refine((item) => {
    return !(item.items.length === 0 && !item.link);
}, (item) => {
    return {
        message: `Sidebar category '${item.label}' has neither any subitem nor a link. This makes this item not able to link to anything.`,
    };
}));
const sidebarItemCategory = parse_1.z.lazy(() => parse_1.z.object({
    type: categoryLiteral,
    label: parse_1.z.string(),
    items: parse_1.z.array(parse_1.z.lazy(() => sidebarItem)),
    link: sidebarItemCategoryLink,
}));
// `discriminatedUnion` currently does not work with recursive types.
// see: https://github.com/colinhacks/zod/issues/1384
// using `union` instead for now with the side-effect of a less clear error message
const sidebarItemConfig = parse_1.z.union([
    sidebarItemCategoryConfig,
    sidebarItemNote,
    sidebarItemAutogenerated,
]);
const sidebarConfig = parse_1.z.array(sidebarItemConfig);
const sidebarItem = parse_1.z.union([sidebarItemCategory, sidebarItemNote]);
const ROOT_KEYWORD = "root";
exports.DefaultSidebar = [
    {
        type: "autogenerated",
        id: ROOT_KEYWORD,
    },
];
exports.DisabledSidebar = [];
const defaultSidebarItemsGenerator = ({ item, notes: notesById, }) => {
    function findHierarchySources() {
        const isTopLevel = item.id === ROOT_KEYWORD;
        // 1. if item-pointer to root find all root notes
        if (isTopLevel) {
            return Object.values(notesById)
                .filter((note) => {
                const { fname } = note;
                if (fname === "root") {
                    return false;
                }
                const hierarchyPath = fname.split(".");
                if (hierarchyPath.length === 1) {
                    return true;
                }
                return false;
            })
                .map(({ id }) => id);
        }
        const note = notesById[item.id];
        if (!note) {
            throw error_1.DendronError.createFromStatus({
                message: `SidebarItem \`${item.id}\` does not exist`,
                status: constants_1.ERROR_STATUS.DOES_NOT_EXIST,
            });
        }
        return note.children;
    }
    function generateSidebar(noteIds) {
        return noteIds
            .map((noteId) => {
            const note = notesById[noteId];
            const fm = utils_1.PublishUtils.getPublishFM(note);
            const { children } = note;
            const hasChildren = children.length > 0;
            const isCategory = hasChildren;
            const isNote = !hasChildren;
            if (!note || fm.nav_exclude) {
                return undefined;
            }
            const positionalProps = {
                position: fm.nav_order,
                fname: note.fname,
                reverse: fm.sort_order === "reverse",
            };
            if (isNote) {
                return {
                    type: "note",
                    id: note.id,
                    label: note.title,
                    ...positionalProps,
                };
            }
            if (isCategory) {
                const shouldIgnoreChildren = fm.nav_exclude_children || fm.has_collection;
                return {
                    type: "category",
                    label: note.title,
                    items: shouldIgnoreChildren ? [] : generateSidebar(children),
                    link: { type: "note", id: note.id },
                    ...positionalProps,
                };
            }
            return undefined;
        })
            .filter((maybeSidebarItem) => Boolean(maybeSidebarItem));
    }
    function sortItems(sidebarItems) {
        const processedSidebarItems = sidebarItems.map((item) => {
            if (item.type === "category") {
                const sortedItems = sortItems(item.items);
                if (item.reverse) {
                    sortedItems.reverse();
                }
                return { ...item, items: sortedItems };
            }
            return item;
        });
        const sortedSidebarItems = lodash_1.default.sortBy(processedSidebarItems, [
            "position",
            "fname",
        ]);
        return sortedSidebarItems.map(({ position, fname, reverse, ...item }) => item);
    }
    const hierarchySource = findHierarchySources();
    return lodash_1.default.flow(generateSidebar, sortItems)(hierarchySource);
};
function processSidebar(sidebarResult, { notes, duplicateNoteBehavior }) {
    function processAutoGeneratedItem(item) {
        return (
        // optional future feature to control sidebarItems generation
        defaultSidebarItemsGenerator({ item, notes }));
    }
    function resolveItem(item) {
        function resolveItemId(sidebarId) {
            var _a;
            const realizableNotes = [
                // 1. check if associated using note id.
                (_a = notes[sidebarId]) !== null && _a !== void 0 ? _a : 
                // 2. find note based on `fname`
                Object.values(notes).filter((note) => {
                    return note.fname === sidebarId;
                }),
            ].flat();
            const getPrioritizedRealizableNotes = () => {
                var _a;
                const map = new Map(realizableNotes.map((note) => {
                    var _a;
                    return [
                        (_a = note.vault.name) !== null && _a !== void 0 ? _a : note.vault.fsPath,
                        note,
                    ];
                }));
                return (_a = getPriorityVaults(duplicateNoteBehavior)) === null || _a === void 0 ? void 0 : _a.filter((vaultName) => map.has(vaultName)).map((vaultName) => map.get(vaultName));
            };
            const hasDuplicates = realizableNotes.length > 1;
            const note = lodash_1.default.first((hasDuplicates && getPrioritizedRealizableNotes()) || realizableNotes);
            if (!note) {
                throw error_1.DendronError.createFromStatus({
                    message: `SidebarItem \`${sidebarId}\` does not exist`,
                    status: constants_1.ERROR_STATUS.DOES_NOT_EXIST,
                });
            }
            return note.id;
        }
        const { type } = item;
        switch (type) {
            case "category": {
                const { link } = item;
                return {
                    ...item,
                    link: { type: "note", id: resolveItemId(link.id) },
                };
            }
            case "autogenerated": {
                return {
                    ...item,
                    id: item.id === ROOT_KEYWORD ? item.id : resolveItemId(item.id),
                };
            }
            case "note": {
                return {
                    ...item,
                    id: resolveItemId(item.id),
                };
            }
            default:
                (0, error_1.assertUnreachable)(type);
        }
    }
    function processItem(_item) {
        const item = resolveItem(_item);
        const { type } = item;
        switch (type) {
            case "category": {
                return [
                    {
                        ...item,
                        items: item.items.map(processItem).flat(),
                    },
                ];
            }
            case "autogenerated":
                return processAutoGeneratedItem(item);
            case "note": {
                return [item];
            }
            default:
                (0, error_1.assertUnreachable)(type);
        }
    }
    const safeProcessItem = (0, utils_1.fromThrowable)(processItem, (error) => error_1.DendronError.isDendronError(error)
        ? error
        : error_1.DendronError.createFromStatus({
            message: "Error when processing sidebarItem",
            status: constants_1.ERROR_STATUS.INVALID_CONFIG,
        }));
    return sidebarResult
        .andThen((sidebar) => utils_1.Result.combine(sidebar.map(safeProcessItem)))
        .map((x) => x.flat());
}
exports.processSidebar = processSidebar;
function parseSidebarConfig(input) {
    if (Array.isArray(input)) {
        const resultList = input.map((maybeSidebarItem) => {
            const { type } = maybeSidebarItem;
            switch (type) {
                case "note":
                    return (0, parse_1.parse)(sidebarItemNote, maybeSidebarItem, `SidebarParseError in ${JSON.stringify(maybeSidebarItem)}`);
                case "autogenerated":
                    return (0, parse_1.parse)(sidebarItemAutogenerated, maybeSidebarItem, `SidebarParseError in ${JSON.stringify(maybeSidebarItem)}`);
                case "category":
                    return (0, parse_1.parse)(sidebarItemConfig, maybeSidebarItem, `SidebarParseError in ${JSON.stringify(maybeSidebarItem)}`);
                default:
                    return (0, utils_1.err)(new error_1.DendronError({
                        message: `Invalid sidebar item type in \`${JSON.stringify(maybeSidebarItem)}\`. Valid are \`${noteLiteral.value}\`, \`${categoryLiteral.value}\` or \`${autogeneratedLiteral.value}\`.`,
                    }));
            }
        });
        // @ts-ignore
        return utils_1.Result.combine(resultList);
    }
    return (0, utils_1.err)(new error_1.DendronError({ message: "Sidebar object is not an array" }));
}
exports.parseSidebarConfig = parseSidebarConfig;
/**

The sidebar gets generated through the following steps:

1. **Parsing**. using [zod](https://github.com/colinhacks/zod) we parse the content of the sidebar config file. Returns `SidbarConfig`.
  - this is inspired by [Parse, don’t validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
  - If we support shorthand (for now we skip it) parsing would also have a transformation step from shorthand to longhand.
  - here we should also check if the hierarchies that the sidebar config points to are actually going to be published. If not an `Result` type should be returned.
2. **Generate**. Generate domains
  - consists of:
    - processing
      - resolving sidebar item `id` attribute
      - resolve autogenerates
*/
function getSidebar(input, options) {
    return processSidebar(parseSidebarConfig(input), options);
}
exports.getSidebar = getSidebar;
/**
 * Returns list of vault names sorted by `duplicateNoteBehavior`
 */
function getPriorityVaults(duplicateNoteBehavior) {
    var _a;
    if (Array.isArray(duplicateNoteBehavior === null || duplicateNoteBehavior === void 0 ? void 0 : duplicateNoteBehavior.payload)) {
        return [...new Set(duplicateNoteBehavior === null || duplicateNoteBehavior === void 0 ? void 0 : duplicateNoteBehavior.payload)];
    }
    const vaultName = (_a = duplicateNoteBehavior === null || duplicateNoteBehavior === void 0 ? void 0 : duplicateNoteBehavior.payload.vault) === null || _a === void 0 ? void 0 : _a.name;
    if (vaultName) {
        return [vaultName];
    }
    return undefined;
}
//# sourceMappingURL=sidebar.js.map