import type { NotePropsByIdDict, DuplicateNoteBehavior } from "./types";
import { Result } from "./utils";
import { z } from "./parse";
import type { IDendronError } from "./error";
export declare type SidebarResult<T> = Result<T, IDendronError>;
declare const sidebarItemCategoryLink: z.ZodObject<{
    type: z.ZodLiteral<"note">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "note";
}, {
    id: string;
    type: "note";
}>;
declare type SidebarItemCategoryConfig = {
    type: "category";
    label: string;
    items: SidebarItemConfig[];
    link: SidebarItemCategoryLink;
};
declare const sidebarItemConfig: z.ZodUnion<[z.ZodType<SidebarItemCategoryConfig, z.ZodTypeDef, SidebarItemCategoryConfig>, z.ZodObject<{
    type: z.ZodLiteral<"note">;
    id: z.ZodString;
    label: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "note";
    label: string;
}, {
    id: string;
    type: "note";
    label: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"autogenerated">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "autogenerated";
}, {
    id: string;
    type: "autogenerated";
}>]>;
declare const sidebarConfig: z.ZodArray<z.ZodUnion<[z.ZodType<SidebarItemCategoryConfig, z.ZodTypeDef, SidebarItemCategoryConfig>, z.ZodObject<{
    type: z.ZodLiteral<"note">;
    id: z.ZodString;
    label: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "note";
    label: string;
}, {
    id: string;
    type: "note";
    label: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"autogenerated">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "autogenerated";
}, {
    id: string;
    type: "autogenerated";
}>]>, "many">;
declare const sidebarItem: z.ZodUnion<[z.ZodType<SidebarItemCategory, z.ZodTypeDef, SidebarItemCategory>, z.ZodObject<{
    type: z.ZodLiteral<"note">;
    id: z.ZodString;
    label: z.ZodString;
}, "strip", z.ZodTypeAny, {
    id: string;
    type: "note";
    label: string;
}, {
    id: string;
    type: "note";
    label: string;
}>]>;
declare type SidebarItemConfig = z.infer<typeof sidebarItemConfig>;
declare type SidebarConfig = z.infer<typeof sidebarConfig>;
declare type SidebarItemCategoryLink = z.infer<typeof sidebarItemCategoryLink>;
declare type SidebarItemCategory = {
    type: "category";
    label: string;
    items: SidebarItem[];
    link: SidebarItemCategoryLink;
};
export declare type SidebarItem = z.infer<typeof sidebarItem>;
export declare type Sidebar = Array<SidebarItem>;
declare type SidebarOptions = {
    duplicateNoteBehavior?: DuplicateNoteBehavior;
    notes: NotePropsByIdDict;
};
export declare const DefaultSidebar: SidebarConfig;
export declare const DisabledSidebar: SidebarConfig;
export declare function processSidebar(sidebarResult: SidebarResult<SidebarConfig>, { notes, duplicateNoteBehavior }: SidebarOptions): SidebarResult<Sidebar>;
export declare function parseSidebarConfig(input: unknown): Result<SidebarConfig, IDendronError>;
/**

The sidebar gets generated through the following steps:

1. **Parsing**. using [zod](https://github.com/colinhacks/zod) we parse the content of the sidebar config file. Returns `SidbarConfig`.
  - this is inspired by [Parse, donâ€™t validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
  - If we support shorthand (for now we skip it) parsing would also have a transformation step from shorthand to longhand.
  - here we should also check if the hierarchies that the sidebar config points to are actually going to be published. If not an `Result` type should be returned.
2. **Generate**. Generate domains
  - consists of:
    - processing
      - resolving sidebar item `id` attribute
      - resolve autogenerates
*/
export declare function getSidebar(input: unknown, options: SidebarOptions): SidebarResult<Sidebar>;
export {};
