"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchAll = exports.getWorkspaceCache = exports.extractDanglingRefs = exports.parseRef = exports.fsPathToRef = exports.normalizeSlashes = exports.trimLeadingSlash = exports.isInFencedCodeBlock = exports.getFileUrlForMarkdownPreview = exports.positionToOffset = exports.lineBreakOffsetsByLineIndex = exports.findUriByRef = exports.refPattern = exports.containsMarkdownExt = exports.REGEX_FENCED_CODE_BLOCK = exports.sortPaths = void 0;
/* eslint-disable no-cond-assign */
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-use-before-define */
const cross_path_sort_1 = require("cross-path-sort");
Object.defineProperty(exports, "sortPaths", { enumerable: true, get: function () { return cross_path_sort_1.sort; } });
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const vscode_uri_1 = require("vscode-uri");
const workspaceCache = {
    imageUris: [],
    markdownUris: [],
    otherUris: [],
    allUris: [],
    danglingRefsByFsPath: {},
    danglingRefs: [],
};
const markdownExtRegex = /\.md$/i;
exports.REGEX_FENCED_CODE_BLOCK = /^( {0,3}|\t)```[^`\r\n]*$[\w\W]+?^( {0,3}|\t)``` *$/gm;
const containsMarkdownExt = (pathParam) => !!markdownExtRegex.exec(path_1.default.parse(pathParam).ext);
exports.containsMarkdownExt = containsMarkdownExt;
exports.refPattern = "(\\[\\[)([^\\[\\]]+?)(\\]\\])";
// === Utils
const findUriByRef = (uris, ref) => {
    return uris.find((uri) => {
        // const relativeFsPath =
        //   path.sep + path.relative(getWorkspaceFolder()!.toLowerCase(), uri.fsPath.toLowerCase());
        // if (containsImageExt(ref) || containsOtherKnownExts(ref) || containsUnknownExt(ref)) {
        //   if (isLongRef(ref)) {
        //     return normalizeSlashes(relativeFsPath).endsWith(ref.toLowerCase());
        //   }
        //   const basenameLowerCased = path.basename(uri.fsPath).toLowerCase();
        //   return (
        //     basenameLowerCased === ref.toLowerCase() || basenameLowerCased === `${ref.toLowerCase()}.md`
        //   );
        // }
        // if (isLongRef(ref)) {
        //   return normalizeSlashes(relativeFsPath).endsWith(`${ref.toLowerCase()}.md`);
        // }
        const name = path_1.default.parse(uri.fsPath).name.toLowerCase();
        return ((0, exports.containsMarkdownExt)(path_1.default.basename(uri.fsPath)) &&
            name === ref.toLowerCase());
    });
};
exports.findUriByRef = findUriByRef;
const lineBreakOffsetsByLineIndex = (value) => {
    const result = [];
    let index = value.indexOf("\n");
    while (index !== -1) {
        result.push(index + 1);
        index = value.indexOf("\n", index + 1);
    }
    result.push(value.length + 1);
    return result;
};
exports.lineBreakOffsetsByLineIndex = lineBreakOffsetsByLineIndex;
const positionToOffset = (content, position) => {
    if (position.line < 0) {
        throw new Error("Illegal argument: line must be non-negative");
    }
    if (position.column < 0) {
        throw new Error("Illegal argument: column must be non-negative");
    }
    const lineBreakOffsetsByIndex = (0, exports.lineBreakOffsetsByLineIndex)(content);
    if (lineBreakOffsetsByIndex[position.line] !== undefined) {
        return ((lineBreakOffsetsByIndex[position.line - 1] || 0) + position.column || 0);
    }
    return 0;
};
exports.positionToOffset = positionToOffset;
const getFileUrlForMarkdownPreview = (filePath) => vscode_uri_1.URI.file(filePath).toString().replace("file://", "");
exports.getFileUrlForMarkdownPreview = getFileUrlForMarkdownPreview;
const isInFencedCodeBlock = (content, lineNum) => {
    const textBefore = content
        .slice(0, (0, exports.positionToOffset)(content, { line: lineNum, column: 0 }))
        .replace(exports.REGEX_FENCED_CODE_BLOCK, "")
        .replace(/<!--[\W\w]+?-->/g, "");
    // So far `textBefore` should contain no valid fenced code block or comment
    return /^( {0,3}|\t)```[^`\r\n]*$[\w\W]*$/gm.test(textBefore);
};
exports.isInFencedCodeBlock = isInFencedCodeBlock;
const trimLeadingSlash = (value) => value.replace(/^\/+|^\\+/g, "");
exports.trimLeadingSlash = trimLeadingSlash;
const normalizeSlashes = (value) => value.replace(/\\/gi, "/");
exports.normalizeSlashes = normalizeSlashes;
const fsPathToRef = ({ path: fsPath, keepExt, basePath, }) => {
    const ref = basePath && fsPath.startsWith(basePath)
        ? (0, exports.normalizeSlashes)(fsPath.replace(basePath, ""))
        : path_1.default.basename(fsPath);
    if (keepExt) {
        return (0, exports.trimLeadingSlash)(ref);
    }
    return (0, exports.trimLeadingSlash)(ref.includes(".") ? ref.slice(0, ref.lastIndexOf(".")) : ref);
};
exports.fsPathToRef = fsPathToRef;
const parseRef = (rawRef) => {
    const dividerPosition = rawRef.indexOf("|");
    if (dividerPosition < 0) {
        return {
            ref: lodash_1.default.trim(rawRef),
            label: lodash_1.default.trim(rawRef),
        };
    }
    else {
        return {
            ref: lodash_1.default.trim(rawRef.slice(dividerPosition + 1, rawRef.length)),
            label: lodash_1.default.trim(rawRef.slice(0, dividerPosition)),
        };
    }
};
exports.parseRef = parseRef;
const refRegexp = new RegExp(exports.refPattern, "gi");
const extractDanglingRefs = (content) => {
    const refs = [];
    content.split(/\r?\n/g).forEach((lineText, _lineNum) => {
        for (const match of (0, exports.matchAll)(refRegexp, lineText)) {
            const [, , reference] = match;
            if (reference) {
                // const offset = (match.index || 0) + 2;
                // if (isInFencedCodeBlock(content, lineNum) || isInCodeSpan(content, lineNum, offset)) {
                //   continue;
                // }
                const { ref } = (0, exports.parseRef)(reference);
                if (!(0, exports.findUriByRef)((0, exports.getWorkspaceCache)().allUris, ref)) {
                    refs.push(ref);
                }
            }
        }
    });
    return Array.from(new Set(refs));
};
exports.extractDanglingRefs = extractDanglingRefs;
const getWorkspaceCache = () => workspaceCache;
exports.getWorkspaceCache = getWorkspaceCache;
const matchAll = (pattern, text) => {
    let match;
    const out = [];
    pattern.lastIndex = 0;
    while ((match = pattern.exec(text))) {
        out.push(match);
    }
    return out;
};
exports.matchAll = matchAll;
//# sourceMappingURL=utils.js.map