"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteDbFactory = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const sqlite3_1 = require("sqlite3");
const vscode_uri_1 = require("vscode-uri");
const file_1 = require("../file");
const SqliteQueryUtils_1 = require("./SqliteQueryUtils");
const tables_1 = require("./tables");
const LinksTableUtils_1 = require("./tables/LinksTableUtils");
const NotePropsFtsTableUtils_1 = require("./tables/NotePropsFtsTableUtils");
const NotePropsTableUtils_1 = require("./tables/NotePropsTableUtils");
const SchemaNotesTableUtils_1 = require("./tables/SchemaNotesTableUtils");
const VaultNotesTableUtils_1 = require("./tables/VaultNotesTableUtils");
/**
 * Factory methods to create a SQLite database
 */
class SqliteDbFactory {
    /**
     * This creates a SQLite database AND also initializes it with all notes that
     * are a part of the passed in vaults
     * @param wsRoot
     * @param vaults
     * @param fileStore
     * @param dbFilePath - path of the db file. Use :memory: to use an in-memory database
     * @returns
     */
    static createInitializedDB(wsRoot, vaults, fileStore, dbFilePath, logger) {
        return SqliteDbFactory.createEmptyDB(dbFilePath).andThen((db) => {
            const results = common_all_1.ResultAsync.combine(
            // Initialize Each Vault
            vaults.map((vault) => {
                const vaultPath = (0, common_server_1.vault2Path)({ vault, wsRoot });
                // Get list of files from the filesystem for the vault
                return common_all_1.ResultAsync.fromPromise(fileStore.readDir({
                    root: vscode_uri_1.URI.parse(vaultPath),
                    include: ["*.md"],
                }), (e) => {
                    return e;
                }).map((maybeFiles) => {
                    // And parse them
                    return (0, file_1.parseAllNoteFilesForSqlite)(maybeFiles.data, vault, db, vaultPath, false, logger);
                });
            }));
            return results.map(() => {
                return db;
            });
        });
    }
    /**
     * This method will create a sqlite database with the table schema created,
     * but no initial data is added. Useful for tests.
     * @param dbFilePath - path of the db file. Use :memory: to use an in-memory database
     * @returns
     */
    static createEmptyDB(dbFilePath) {
        const prom = new Promise((resolve, reject) => {
            const db = new sqlite3_1.Database(dbFilePath, (err) => {
                if (err) {
                    reject(err.message);
                }
                resolve(db);
            });
        });
        return common_all_1.ResultAsync.fromPromise(prom, (e) => {
            return e;
        }).andThen((db) => {
            // First create the relation-less tables first (vaults and NoteProps):
            return common_all_1.ResultAsync.combine([
                tables_1.VaultsTableUtils.createTable(db),
                NotePropsTableUtils_1.NotePropsTableUtils.createTable(db),
                LinksTableUtils_1.LinksTableUtils.createTable(db),
            ])
                .andThen(() => {
                // Now create tables with relations
                return common_all_1.ResultAsync.combine([
                    VaultNotesTableUtils_1.VaultNotesTableUtils.createTable(db),
                    tables_1.HierarchyTableUtils.createTable(db),
                    SchemaNotesTableUtils_1.SchemaNotesTableUtils.createTable(db),
                    NotePropsFtsTableUtils_1.NotePropsFtsTableUtils.createTable(db),
                    // Enable Foreign Key relationships:
                    SqliteQueryUtils_1.SqliteQueryUtils.run(db, "PRAGMA foreign_keys = ON"),
                ]);
            })
                .map(() => {
                return db;
            });
        });
    }
    static initSchema(vaults, wsRoot, fileStore, logger) {
        const schemaParser = new file_1.SchemaParser({
            wsRoot,
            logger,
        });
        const schemaDict = {};
        let errors = [];
        common_all_1.ResultAsync.combineWithAllErrors(vaults.map((vault) => {
            const vaultPath = (0, common_server_1.vault2Path)({ vault, wsRoot });
            return common_all_1.ResultUtils.PromiseRespV3ToResultAsync(fileStore.readDir({
                root: vscode_uri_1.URI.file(vaultPath),
                include: ["*.schema.yml"],
            })).andThen((schemaFiles) => {
                const out = common_all_1.ResultAsync.fromSafePromise(schemaParser.parse(schemaFiles, vault));
                return out;
            });
        })).map((res) => {
            const schemaResponses = res;
            errors = schemaResponses
                .flatMap((response) => response.errors)
                .filter(common_all_1.isNotNull);
            const schemas = schemaResponses
                .flatMap((response) => response.schemas)
                .filter(common_all_1.isNotUndefined);
            schemas.forEach((schema) => {
                schemaDict[schema.root.id] = schema;
            });
        });
        if (errors.length > 0) {
            return (0, common_all_1.errAsync)(new common_all_1.DendronCompositeError(errors));
        }
        else {
            return (0, common_all_1.okAsync)(schemaDict);
        }
    }
}
exports.SqliteDbFactory = SqliteDbFactory;
//# sourceMappingURL=SqliteDbFactory.js.map