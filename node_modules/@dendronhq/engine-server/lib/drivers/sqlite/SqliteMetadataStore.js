"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteMetadataStore = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const SqliteDbFactory_1 = require("./SqliteDbFactory");
const tables_1 = require("./tables");
const SchemaNotesTableUtils_1 = require("./tables/SchemaNotesTableUtils");
class SqliteMetadataStore {
    constructor(_db, _vaults) {
        this._db = _db;
        this._vaults = _vaults;
    }
    /**
     * Goes through all domains and recursively apply schemas.
     */
    async initSchema(fileStore, wsRoot, logger) {
        // TODO: move this whole thing to parseAllNoteFilesForSqlite / SqliteDbFactory
        const schemaResult = await SqliteDbFactory_1.SqliteDbFactory.initSchema(this._vaults, wsRoot, fileStore, logger);
        if (schemaResult.isErr()) {
            throw schemaResult.error;
        }
        const schemas = schemaResult.value;
        const rootNotesResult = await this.query({ qs: "", originalQS: "" });
        if (rootNotesResult.isErr()) {
            throw rootNotesResult.error;
        }
        const rootNotes = rootNotesResult.value;
        const rootNoteIds = rootNotes.map((rootNoteMeta) => {
            return rootNoteMeta.id;
        });
        // TODO: break this down
        await Promise.all(rootNoteIds.map(async (rootId) => {
            const rootNoteResp = await this.get(rootId);
            if (rootNoteResp.error) {
                throw rootNoteResp.error;
            }
            else {
                const domainIds = rootNoteResp.data.children;
                const allNoteIdsInDomains = lodash_1.default.uniq(lodash_1.default.flatten(await Promise.all(domainIds.map(async (domainId) => {
                    const getAllInDomainResult = await tables_1.HierarchyTableUtils.getAllDescendants(this._db, domainId, logger);
                    if (getAllInDomainResult.isErr()) {
                        throw getAllInDomainResult.error;
                    }
                    const allInDomainRows = getAllInDomainResult.value;
                    return [domainId].concat(allInDomainRows.map((row) => {
                        return row.childId;
                    }));
                }))));
                // this is too expensive
                // we can probably create NoteDicts from just the query
                const allNotesInDomains = (await Promise.all(allNoteIdsInDomains.map(async (id) => {
                    return (await this.get(id)).data;
                }))).filter(common_all_1.isNotUndefined);
                const domainNotes = allNotesInDomains.filter((note) => {
                    return !note.fname.includes(".");
                });
                const dicts = common_all_1.NoteDictsUtils.createNoteDicts(allNotesInDomains);
                domainNotes.forEach((domainNote) => {
                    common_all_1.SchemaUtils.matchDomain(domainNote, dicts.notesById, schemas);
                });
                const notesWithSchema = allNotesInDomains.filter((note) => {
                    return note.schema !== undefined;
                });
                // we wipe out note -> schema mapping (SchemaNotes table) since this changes every session
                // because of automatically generated schemas
                await SchemaNotesTableUtils_1.SchemaNotesTableUtils.truncate(this._db);
                // do we actually need to filter it here?
                // is INSERT OR IGNORE more expensive than a filter?
                await Promise.all(notesWithSchema.map(async (note) => {
                    await SchemaNotesTableUtils_1.SchemaNotesTableUtils.insert(this._db, {
                        noteId: note.id,
                        ...note.schema,
                    });
                }));
                return allNoteIdsInDomains;
            }
        }));
        return schemas;
    }
    dispose() {
        this._db.close();
    }
    async get(key) {
        const finalResult = await this._get(key);
        if (finalResult.isOk()) {
            return {
                data: finalResult.value,
            };
        }
        else {
            return {
                // Parity error message with NoteMetadataStore
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.CONTENT_NOT_FOUND,
                    message: `NoteProps metadata not found for key ${key}.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }),
            };
        }
    }
    _get(key) {
        const getNotePropsResult = tables_1.NotePropsTableUtils.getById(this._db, key);
        const getDLinksResult = tables_1.LinksTableUtils.getAllDLinks(this._db, key);
        const getChildrenResult = tables_1.HierarchyTableUtils.getChildren(this._db, key);
        const getParentResult = tables_1.HierarchyTableUtils.getParent(this._db, key);
        const getVaultResult = tables_1.VaultNotesTableUtils.getVaultFsPathForNoteId(this._db, key).andThen((fsPath) => {
            const vault = this._vaults.find((vault) => vault.fsPath === fsPath);
            if (!vault) {
                return (0, common_all_1.err)(new Error(`Unable to find vault for note with ID ${key}`));
            }
            else {
                return (0, common_all_1.ok)(vault);
            }
        });
        const getSchemaResult = SchemaNotesTableUtils_1.SchemaNotesTableUtils.getByNoteId(this._db, key).map((row) => lodash_1.default.omit(row, "noteId"));
        return common_all_1.ResultAsync.combineWithAllErrors([
            getNotePropsResult,
            getDLinksResult,
            getChildrenResult,
            getParentResult,
            getVaultResult,
            getSchemaResult,
        ]).andThen((results) => {
            var _a, _b, _c, _d, _e, _f;
            // need to do this here because neverthrow doesn't know what to do
            // when the array length is over 5.
            // neverthrow caps the combine-able array size to 5 to prevent
            // infinite recursion in type inferring with no straightforward way modify the cap.
            const _results = results;
            const row = _results[0];
            if (!row) {
                return (0, common_all_1.errAsync)(new Error(`Unable to find NoteProps for id ${key}`));
            }
            const links = _results[1];
            const children = _results[2];
            const parent = _results[3];
            const vault = _results[4];
            const schema = _results[5];
            const data = {
                parent,
                children,
                links,
                id: row.id,
                fname: row.fname,
                title: row.title,
                desc: (_a = row.description) !== null && _a !== void 0 ? _a : "",
                updated: row.updated,
                created: row.created,
                anchors: (_b = JSON.parse(row.anchors)) !== null && _b !== void 0 ? _b : {},
                stub: row.stub === 1,
                custom: (_c = JSON.parse(row.custom)) !== null && _c !== void 0 ? _c : undefined,
                contentHash: row.contentHash,
                color: (_d = row.color) !== null && _d !== void 0 ? _d : undefined,
                image: (_e = JSON.parse(row.image)) !== null && _e !== void 0 ? _e : undefined,
                traits: (_f = JSON.parse(row.traits)) !== null && _f !== void 0 ? _f : undefined,
                data: {},
                type: "note",
                vault,
                schema: lodash_1.default.isEmpty(schema) ? undefined : schema,
            };
            return (0, common_all_1.okAsync)(data);
        });
    }
    // TODO: If the query building requirements starts to get more complex, maybe
    // we can consider using a library such as knex.js https://knexjs.org/
    async find(opts) {
        // Special case: if no arguments are passed, return nothing.
        if (opts.excludeStub === undefined &&
            opts.fname === undefined &&
            opts.vault === undefined) {
            return {
                data: [],
            };
        }
        const fNameConditionalClause = opts.fname
            ? `fname = '${opts.fname}'`
            : `1 = 1`;
        const excludeStubClause = opts.excludeStub ? `stub = 0` : `1 = 1`;
        let vaultClause = `1 = 1`;
        let vaultJoinClause = ` `;
        if (opts.vault) {
            const vaultIdResponse = await tables_1.VaultsTableUtils.getIdByFsPath(this._db, opts.vault.fsPath);
            if (vaultIdResponse.isErr()) {
                return {
                    error: vaultIdResponse.error,
                };
            }
            vaultJoinClause = `JOIN VaultNotes ON NoteProps.id = VaultNotes.noteId `;
            vaultClause = `VaultNotes.vaultId = ${vaultIdResponse.value}`;
        }
        const sql = `
    SELECT id FROM NoteProps
    ${vaultJoinClause}
    WHERE
    ${lodash_1.default.join([fNameConditionalClause, excludeStubClause, vaultClause], " AND ")}
    `;
        try {
            const ids = await new Promise((resolve, reject) => {
                let ids = [];
                this._db.all(sql, (err, rows) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        ids = rows.map((row) => row.id);
                        resolve(ids);
                    }
                });
            });
            const results = await Promise.all(ids.map(async (id) => {
                const res = await this._get(id);
                if (res.isOk()) {
                    return res.value;
                }
                return undefined;
            }));
            const data = lodash_1.default.compact(results);
            return {
                data,
            };
        }
        catch (e) {
            return {
                error: e,
            };
        }
    }
    async write(key, data) {
        const insertResult = await tables_1.NotePropsTableUtils.insert(this._db, data);
        if (insertResult.isErr()) {
            return {
                error: insertResult.error,
            };
        }
        const vaultId = await tables_1.VaultsTableUtils.getIdByFsPath(this._db, data.vault.fsPath);
        if (vaultId.isErr()) {
            return {
                error: vaultId.error,
            };
        }
        // In case we are changing vaults, the row must be deleted first and then
        // reinserted.
        const vaultNotesDeleteResult = await tables_1.VaultNotesTableUtils.delete(this._db, new tables_1.VaultNotesTableRow(vaultId.value, data.id));
        if (vaultNotesDeleteResult.isErr()) {
            return {
                error: vaultNotesDeleteResult.error,
            };
        }
        const vaultNotesInsertResult = await tables_1.VaultNotesTableUtils.insert(this._db, new tables_1.VaultNotesTableRow(vaultId.value, data.id));
        if (vaultNotesInsertResult.isErr()) {
            return {
                error: vaultNotesInsertResult.error,
            };
        }
        // First we need to clear any existing links
        const linksDeleteResult = await tables_1.LinksTableUtils.delete(this._db, key);
        if (linksDeleteResult.isErr()) {
            return {
                error: linksDeleteResult.error,
            };
        }
        // Now add links
        await Promise.all(data.links.map((link) => {
            var _a;
            return tables_1.LinksTableUtils.insertLinkWithSinkAsFname(this._db, {
                source: data.id,
                sinkFname: link.value,
                type: link.type,
                sinkVaultName: (_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName,
                payload: link,
            });
        }));
        // Potentially any unresolved links now are resolved with the addition of this note
        if (data.vault.name) {
            const updateUnresolvedLinksForAddedNotesResult = await tables_1.LinksTableUtils.updateUnresolvedLinksForAddedNotes(this._db, [data], data.vault.name);
            if (updateUnresolvedLinksForAddedNotesResult.isErr()) {
                return {
                    error: updateUnresolvedLinksForAddedNotesResult.error,
                };
            }
        }
        // Potentially some links became ambiguous
        const insertLinksThatBecameAmbiguousResult = await tables_1.LinksTableUtils.InsertLinksThatBecameAmbiguous(this._db, [
            { fname: data.fname, id: data.id },
        ]);
        if (insertLinksThatBecameAmbiguousResult.isErr()) {
            return {
                error: insertLinksThatBecameAmbiguousResult.error,
            };
        }
        // Now add children
        await Promise.all(data.children.map(async (child) => {
            const childInsertResult = await tables_1.HierarchyTableUtils.insert(this._db, new tables_1.HierarchyTableRow(data.id, child));
            if (childInsertResult.isErr()) {
                // TODO: Handle
            }
            return childInsertResult;
        }));
        // Now add the parent-> child link (where this note is the child):
        if (data.parent) {
            const parentInsertResult = await tables_1.HierarchyTableUtils.insert(this._db, new tables_1.HierarchyTableRow(data.parent, data.id));
            if (parentInsertResult.isErr()) {
                return {
                    error: parentInsertResult.error,
                };
            }
        }
        if (data.schema) {
            await SchemaNotesTableUtils_1.SchemaNotesTableUtils.insert(this._db, {
                noteId: data.id,
                moduleId: data.schema.moduleId,
                schemaId: data.schema.schemaId,
            });
        }
        return { data: key };
    }
    async delete(key) {
        const result = await tables_1.NotePropsTableUtils.delete(this._db, key);
        if (result.isOk()) {
            return {
                data: key,
            };
        }
        else {
            return {
                error: result.error,
            };
        }
    }
    query(opts) {
        // Special case: return all root notes
        if (opts.qs === "") {
            const result = tables_1.NotePropsTableUtils.getByFname(this._db, "root");
            return result.andThen((rows) => {
                const ids = rows.map((row) => row.id);
                const mappingResult = ids.map((id) => {
                    return this._get(id);
                });
                return common_all_1.ResultAsync.combine(mappingResult);
            });
        }
        // if (qs === "") {
        //   const results = this.notesIndex.search("root");
        //   items = _.map(
        //     _.filter(results, (ent) => ent.item.fname === "root"),
        //     (ent) => ent.item
        //   );
        //   /// seearch eveyrthing
        // } else if (qs === "*") {
        //   // @ts-ignore
        //   items = this.notesIndex._docs as NoteProps[];
        // }
        const res = tables_1.NotePropsFtsTableUtils.query(this._db, opts.qs);
        return res.andThen((ids) => {
            const mappingResult = ids.map((id) => {
                return this._get(id);
            });
            return common_all_1.ResultAsync.combine(mappingResult);
        });
    }
}
exports.SqliteMetadataStore = SqliteMetadataStore;
//# sourceMappingURL=SqliteMetadataStore.js.map