"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultNotesTableUtils = exports.VaultNotesTableRow = void 0;
const common_all_1 = require("@dendronhq/common-all");
const SqliteError_1 = require("../SqliteError");
const SqliteQueryUtils_1 = require("../SqliteQueryUtils");
class VaultNotesTableRow {
    constructor(vaultId, noteId) {
        this.vaultId = vaultId;
        this.noteId = noteId;
    }
}
exports.VaultNotesTableRow = VaultNotesTableRow;
/**
 * Utilities for read/write on the VaultNotes Table in sqlite
 */
class VaultNotesTableUtils {
    static createTable(db) {
        const sql = `
    CREATE TABLE IF NOT EXISTS VaultNotes (
      vaultId INTEGER NOT NULL,
      noteId TEXT NOT NULL,
      PRIMARY KEY (vaultId, noteId),
      FOREIGN KEY(vaultId) REFERENCES Vaults(id) ON DELETE CASCADE,
      FOREIGN KEY(noteId) REFERENCES NoteProps(id) ON DELETE CASCADE);`;
        const idx = `CREATE INDEX IF NOT EXISTS idx_VaultNotes_noteId ON VaultNotes (noteId)`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql).andThen(() => {
            return SqliteQueryUtils_1.SqliteQueryUtils.run(db, idx);
        });
    }
    static getVaultFsPathForNoteId(db, noteId) {
        const sql = `
      SELECT fsPath FROM VaultNotes
      JOIN Vaults ON Vaults.id = VaultNotes.vaultId
      WHERE noteId = '${noteId}';`;
        return SqliteQueryUtils_1.SqliteQueryUtils.get(db, sql).andThen((row) => {
            if (!row) {
                const err = {
                    type: SqliteError_1.SqliteErrorType.NoResults,
                    query: sql,
                    name: SqliteError_1.SqliteErrorType.NoResults,
                    message: `No note or vault found for note with ID ${noteId}`,
                };
                return (0, common_all_1.errAsync)(err);
            }
            return (0, common_all_1.okAsync)(row.fsPath);
        });
    }
    static insert(db, row) {
        const sql = `
      INSERT INTO VaultNotes (vaultId, noteId)
      VALUES (
        ${row.vaultId},
        '${row.noteId}'
      );`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static bulkInsert(db, rows) {
        const values = rows
            .map((row) => `('${row.vaultId}', '${row.noteId}')`)
            .join(",");
        const sql = `
      INSERT INTO VaultNotes (vaultId, noteId)
      VALUES ${values}`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static delete(db, row) {
        const sql = `
      DELETE FROM VaultNotes
      WHERE vaultId = ${row.vaultId} AND noteId = '${row.noteId}';`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
}
exports.VaultNotesTableUtils = VaultNotesTableUtils;
//# sourceMappingURL=VaultNotesTableUtils.js.map