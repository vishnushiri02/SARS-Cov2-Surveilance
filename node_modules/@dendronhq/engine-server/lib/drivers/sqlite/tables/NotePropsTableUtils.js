"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotePropsTableUtils = exports.NotePropsTableRow = void 0;
const common_all_1 = require("@dendronhq/common-all");
const SqliteError_1 = require("../SqliteError");
const SqliteQueryUtils_1 = require("../SqliteQueryUtils");
const SqliteTypeUtils_1 = require("../SqliteTypeUtils");
class NotePropsTableRow {
    constructor(id, fname, title, description, updated, created, anchors, stub, custom, contentHash, color, image, traits) {
        this.id = id;
        this.fname = fname;
        this.title = title;
        this.description = description;
        this.updated = updated;
        this.created = created;
        this.anchors = anchors;
        this.stub = stub;
        this.custom = custom;
        this.contentHash = contentHash;
        this.color = color;
        this.image = image;
        this.traits = traits;
    }
}
exports.NotePropsTableRow = NotePropsTableRow;
class NotePropsTableUtils {
    /**
     * Create the NoteProps table in the given sqlite database
     * @param db
     * @returns
     */
    static createTable(db) {
        const sql = `
      CREATE TABLE IF NOT EXISTS NoteProps (
        id TEXT NOT NULL PRIMARY KEY,
        fname TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        updated INTEGER,
        created INTEGER,
        anchors TEXT,
        stub BOOLEAN,
        custom TEXT,
        contentHash TEXT,
        color TEXT,
        image TEXT,
        traits TEXT);`;
        const idx = `CREATE INDEX IF NOT EXISTS idx_NoteProps_fname ON NoteProps (fname)`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql).andThen(() => {
            return SqliteQueryUtils_1.SqliteQueryUtils.run(db, idx);
        });
    }
    /**
     * Get a row by the note id
     * @param db
     * @param id
     * @returns ResultAsync containing the NotePropsTableRow if it exists,
     * otherwise null if a row with the id doesn't exist.
     */
    static getById(db, id) {
        const sql = `SELECT * FROM NoteProps WHERE id = '${id}'`;
        return SqliteQueryUtils_1.SqliteQueryUtils.get(db, sql).map((row) => row !== null && row !== void 0 ? row : null);
    }
    /**
     * Get all rows by fname
     * @param db
     * @param fname
     * @returns
     */
    static getByFname(db, fname) {
        const sql = `SELECT * FROM NoteProps WHERE fname = '${fname}'`;
        return SqliteQueryUtils_1.SqliteQueryUtils.all(db, sql).andThen((rows) => {
            if (!rows) {
                const err = {
                    type: SqliteError_1.SqliteErrorType.NoResults,
                    query: sql,
                    name: SqliteError_1.SqliteErrorType.NoResults,
                    message: `No rows with fname ${fname} found`,
                };
                return (0, common_all_1.errAsync)(err);
            }
            return (0, common_all_1.okAsync)(rows);
        });
    }
    static getHashByFnameAndVaultId(db, fname, vaultId) {
        const sql = `
      SELECT contentHash
      FROM NoteProps
      JOIN VaultNotes ON VaultNotes.noteId = NoteProps.id
      WHERE fname = '${fname}'
      AND VaultNotes.vaultId = ${vaultId}`;
        return SqliteQueryUtils_1.SqliteQueryUtils.get(db, sql).map((row) => row ? row.contentHash : null);
    }
    /**
     * Insert a NoteProp object in the NoteProps sqlite table
     * @param db
     * @param row
     * @returns
     */
    static insert(db, row) {
        const sql = this.getSQLInsertString(row);
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static delete(db, key) {
        const sql = `DELETE FROM NoteProps
    WHERE id = '${key}'`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static getSQLInsertString(props) {
        const sql = `
    INSERT INTO NoteProps (id, fname, title, description, updated, created, anchors, stub, custom, contentHash, color, image, traits)
    VALUES (
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.id)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.fname)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.title)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.desc)},
      ${(0, SqliteTypeUtils_1.getIntegerString)(props.updated)},
      ${(0, SqliteTypeUtils_1.getIntegerString)(props.created)},
      ${(0, SqliteTypeUtils_1.getJSONString)(props.anchors)},
      ${(0, SqliteTypeUtils_1.getSQLBoolean)(props.stub)},
      ${(0, SqliteTypeUtils_1.getJSONString)(props.custom)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.contentHash)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(props.color)},
      ${(0, SqliteTypeUtils_1.getJSONString)(props.image)},
      ${(0, SqliteTypeUtils_1.getJSONString)(props.traits)})
    ON CONFLICT(id) DO UPDATE
    SET
      fname = ${(0, SqliteTypeUtils_1.getSQLValueString)(props.fname)},
      title = ${(0, SqliteTypeUtils_1.getSQLValueString)(props.title)},
      description = ${(0, SqliteTypeUtils_1.getSQLValueString)(props.desc)},
      updated = ${(0, SqliteTypeUtils_1.getIntegerString)(props.updated)},
      created = ${(0, SqliteTypeUtils_1.getIntegerString)(props.created)},
      anchors = ${(0, SqliteTypeUtils_1.getJSONString)(props.anchors)},
      stub = ${(0, SqliteTypeUtils_1.getSQLBoolean)(props.stub)},
      custom = ${(0, SqliteTypeUtils_1.getJSONString)(props.custom)},
      contentHash = ${(0, SqliteTypeUtils_1.getSQLValueString)(props.contentHash)},
      color = ${(0, SqliteTypeUtils_1.getSQLValueString)(props.color)},
      image = ${(0, SqliteTypeUtils_1.getJSONString)(props.image)},
      traits = ${(0, SqliteTypeUtils_1.getJSONString)(props.traits)}`;
        return sql;
    }
}
exports.NotePropsTableUtils = NotePropsTableUtils;
//# sourceMappingURL=NotePropsTableUtils.js.map