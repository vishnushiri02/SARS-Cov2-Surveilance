"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultsTableUtils = exports.VaultsTableRow = void 0;
const common_all_1 = require("@dendronhq/common-all");
const SqliteError_1 = require("../SqliteError");
const SqliteQueryUtils_1 = require("../SqliteQueryUtils");
class VaultsTableRow {
    constructor(id, name, fsPath) {
        this.id = id;
        this.name = name;
        this.fsPath = fsPath;
    }
}
exports.VaultsTableRow = VaultsTableRow;
class VaultsTableUtils {
    static createTable(db) {
        const sql = `
    CREATE TABLE IF NOT EXISTS Vaults (
      id INTEGER PRIMARY KEY,
      name TEXT,
      fsPath TEXT
    )`;
        const sqlIndex = `
    CREATE UNIQUE INDEX IF NOT EXISTS idx_vaults_fsPath ON Vaults ('fsPath')`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql).andThen(() => {
            return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sqlIndex);
        });
    }
    static getIdByFsPath(db, fsPath) {
        const sql = `
      SELECT id FROM Vaults
      WHERE fsPath = '${fsPath}'`;
        return SqliteQueryUtils_1.SqliteQueryUtils.get(db, sql).andThen((row) => {
            if (!row) {
                const err = {
                    type: SqliteError_1.SqliteErrorType.NoResults,
                    query: sql,
                    name: SqliteError_1.SqliteErrorType.NoResults,
                    message: `No vault with fsPath ${fsPath} found.`,
                };
                return (0, common_all_1.errAsync)(err);
            }
            return (0, common_all_1.okAsync)(row.id);
        });
    }
    static insert(db, row) {
        const sql = `
      INSERT INTO Vaults (name, fsPath)
      VALUES (
        '${row.name}',
        '${row.fsPath}'
      );`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
}
exports.VaultsTableUtils = VaultsTableUtils;
//# sourceMappingURL=VaultsTableUtils.js.map