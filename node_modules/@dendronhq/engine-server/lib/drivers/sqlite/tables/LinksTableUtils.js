"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksTableUtils = exports.LinksTableRow = void 0;
const lodash_1 = __importDefault(require("lodash"));
const SqliteQueryUtils_1 = require("../SqliteQueryUtils");
const SqliteTypeUtils_1 = require("../SqliteTypeUtils");
class LinksTableRow {
    constructor(source, // NOTE: These are ID's, not fnames!
    sink, // NOTE: These are ID's, not fnames!
    type, sinkFname, sinkVaultName, payload) {
        this.source = source;
        this.sink = sink;
        this.type = type;
        this.sinkFname = sinkFname;
        this.sinkVaultName = sinkVaultName;
        this.payload = payload;
    }
}
exports.LinksTableRow = LinksTableRow;
class LinksTableUtils {
    static createTable(db) {
        const sql = `
    CREATE TABLE IF NOT EXISTS Links (
      source TEXT NOT NULL,
      sink TEXT,
      linkType INTEGER,
      sinkFname TEXT, -- DNoteLoc property
      sinkVaultName TEXT, -- DNoteLoc property
      payload TEXT,
      PRIMARY KEY (source, sink, payload),
      FOREIGN KEY(source) REFERENCES NoteProps(id) ON DELETE CASCADE,
      FOREIGN KEY(sink) REFERENCES NoteProps(id) ON DELETE SET NULL
    )`;
        const idx = `CREATE INDEX IF NOT EXISTS idx_Links_source ON Links (source)`;
        const idx2 = `CREATE INDEX IF NOT EXISTS idx_Links_sink ON Links (sink)`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql)
            .andThen(() => {
            return SqliteQueryUtils_1.SqliteQueryUtils.run(db, idx);
        })
            .andThen(() => {
            return SqliteQueryUtils_1.SqliteQueryUtils.run(db, idx2);
        });
    }
    static insert(db, row) {
        const sql = `
    INSERT INTO Links (source, sink, linkType, sinkFname, sinkVaultName, payload)
    VALUES (
      ${(0, SqliteTypeUtils_1.getSQLValueString)(row.source)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(row.sink)},
      ${(0, SqliteTypeUtils_1.getIntegerString)(LinksTableUtils.getSQLValueForLinkType(row.type))},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(row.sinkFname)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(row.sinkVaultName)},
      ${(0, SqliteTypeUtils_1.getSQLValueString)(row.payload ? JSON.stringify(row.payload) : undefined)})
      `;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static bulkInsertLinkWithSinkAsFname(db, data) {
        const values = data
            .map((d) => `('${d.source}','${d.sinkFname}',${LinksTableUtils.getSQLValueForLinkType(d.type)},${(0, SqliteTypeUtils_1.getSQLValueString)(d.sinkFname)},${(0, SqliteTypeUtils_1.getSQLValueString)(d.sinkVaultName)},${d.payload ? "'" + JSON.stringify(d.payload) + "'" : "NULL"})`)
            .join(",");
        const sql = `
      INSERT OR IGNORE INTO Links (source, sink, linkType, sinkFname, sinkVaultName, payload)
      WITH T(source, fname, linkType, sinkFname, sinkVaultName, payload) AS
      (VALUES ${values})
      SELECT T.source, NoteProps.id, T.linkType, T.sinkFname, T.sinkVaultName, T.payload FROM T
      LEFT OUTER JOIN NoteProps ON T.fname = NoteProps.fname`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static bulkInsertLinkCandidatesWithSinkAsFname(db, data) {
        const values = data
            .map((d) => `('${d.source}','${d.sinkFname}',${LinksTableUtils.getSQLValueForLinkType(d.type)},${(0, SqliteTypeUtils_1.getSQLValueString)(d.sinkFname)},${(0, SqliteTypeUtils_1.getSQLValueString)(d.sinkVaultName)},${d.payload ? "'" + JSON.stringify(d.payload) + "'" : "NULL"})`)
            .join(",");
        const sql = `
      INSERT OR IGNORE INTO Links (source, sink, linkType, sinkFname, sinkVaultName, payload)
      WITH T(source, fname, linkType, sinkFname, sinkVaultName, payload) AS
      (VALUES ${values})
      SELECT T.source, NoteProps.id, T.linkType, T.sinkFname, T.sinkVaultName, T.payload FROM T
      JOIN NoteProps ON T.fname = NoteProps.fname`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static InsertLinksThatBecameAmbiguous(db, data) {
        const values = data
            .map((d) => `(${(0, SqliteTypeUtils_1.getSQLValueString)(d.fname)},${(0, SqliteTypeUtils_1.getSQLValueString)(d.id)})`)
            .join(",");
        const sql = `
      INSERT OR IGNORE INTO Links (source, sink, linkType, sinkFname, sinkVaultName, payload)
      WITH T(fname, id) AS
      (VALUES ${values})
      SELECT Links.source, T.id, Links.linkType, Links.sinkFname, Links.sinkVaultName, Links.payload
      FROM T
      JOIN Links ON Links.sinkFname = T.fname AND Links.sinkVaultName IS NULL`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    /**
     * Use this method when you have the ID of the source and the fname of the
     * sink. This method will lookup into the NoteProps table to get ID's for the
     * sink (if any valid ID's exist). This is
     */
    static insertLinkWithSinkAsFname(db, data) {
        return LinksTableUtils.bulkInsertLinkWithSinkAsFname(db, [data]);
    }
    /**
     *  For a note ID, get anything that shows up in NotePropsMeta.links (this
     *  includes forward and backlinks, excludes parent/children)
     * @param db
     * @param noteId
     * @returns
     */
    static getAllDLinks(db, noteId) {
        const sql = `
      SELECT source, sink, linkType, payload
      FROM Links
      WHERE (source = '${noteId}' OR sink = '${noteId}')`;
        return SqliteQueryUtils_1.SqliteQueryUtils.all(db, sql).map((rows) => {
            const dlinks = [];
            rows.map((row) => {
                // Forward Links:
                if (row.source === noteId && row.payload) {
                    dlinks.push(JSON.parse(row.payload)); // TODO - prolly need to change type in LinksTableRow to string instead of DLink
                }
                else if (row.sink === noteId) {
                    const link = JSON.parse(row.payload);
                    const backlink = {
                        type: "backlink",
                        value: link.value,
                        position: link.position,
                        from: link.from,
                    };
                    dlinks.push(backlink);
                }
            });
            // An ambiguous wikilink will have multiple entries in the links
            // table, so we need to dedupe here:
            return lodash_1.default.uniqWith(dlinks, lodash_1.default.isEqual);
        });
    }
    static delete(db, source) {
        const sql = `
      DELETE FROM Links
      WHERE source = '${source}'`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static updateUnresolvedLinksForAddedNotes(db, addedNotes, vaultNameOfNotesGettingAdded) {
        const values = addedNotes
            .map((props) => `('${props.fname}','${props.id}','${vaultNameOfNotesGettingAdded}')`)
            .join(",");
        // TODO: Handle cross-vault link syntax in the linkValue
        const sql = `
    UPDATE Links
    SET sink = AddedNotes.newId
    FROM
    (
      WITH T(fname, id, vaultName) AS
        (VALUES ${values})
        SELECT T.id AS newId, Links.source, links.payload
        FROM T
        JOIN Links ON Links.sinkFname = T.fname AND Links.sink IS NULL AND (Links.sinkVaultName = T.vaultName OR Links.sinkVaultName IS NULL)
    ) AS AddedNotes
    WHERE Links.source = AddedNotes.source
    AND Links.payload = AddedNotes.payload`;
        return SqliteQueryUtils_1.SqliteQueryUtils.run(db, sql);
    }
    static getSQLValueForLinkType(type) {
        switch (type) {
            case "wiki":
                return 1;
            case "md":
                return 2;
            case "ref":
                return 3;
            case "frontmatterTag":
                return 4;
            default:
                return 0;
        }
    }
}
exports.LinksTableUtils = LinksTableUtils;
//# sourceMappingURL=LinksTableUtils.js.map