"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteQueryUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const SqliteError_1 = require("./SqliteError");
/**
 * Static Utils that help run sqlite database queries. Instead of taking
 * callbacks like the sqlite3 library, these methods will return an awaitable
 * ResultAsync and package Sqlite query errors into a SqliteError object.
 */
class SqliteQueryUtils {
    static run(db, sql, logger) {
        const start = process.hrtime();
        const prom = new Promise((resolve, reject) => {
            db.run(sql, (err) => {
                if (err) {
                    logger === null || logger === void 0 ? void 0 : logger.error(`SqliteQueryUtils.run() failed with error message ${err.message} in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${SqliteQueryUtils.formatQueryString(sql)}`);
                    reject(err.message);
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.info(`Executed SqliteQueryUtils.run() in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${SqliteQueryUtils.formatQueryString(sql)}`);
                    resolve(null);
                }
            });
        });
        return common_all_1.ResultAsync.fromPromise(prom, (e) => {
            return this.getSqliteError(e, sql);
        });
    }
    /**
     * Runs Database.get() method of sqlite3 and packages the result (first row)
     * in an awaitable ResultAsync
     * @param db
     * @param sql
     * @param logger
     * @returns
     */
    static get(db, sql, logger) {
        const start = process.hrtime();
        const prom = new Promise((resolve, reject) => {
            db.get(sql, (err, row) => {
                if (err) {
                    logger === null || logger === void 0 ? void 0 : logger.error(`SqliteQueryUtils.get() failed with error message ${err.message} in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${SqliteQueryUtils.formatQueryString(sql)}`);
                    reject(err.message);
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.info(`Executed SqliteQueryUtils.get() query in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${SqliteQueryUtils.formatQueryString(sql)}`);
                    resolve(row);
                }
            });
        });
        return common_all_1.ResultAsync.fromPromise(prom, (e) => {
            return this.getSqliteError(e, sql);
        });
    }
    /**
     * Runs Database.all() method of sqlite3 and packages the result (array of
     * rows) in an awaitable ResultAsync
     * @param db
     * @param sql
     * @param logger
     * @returns
     */
    static all(db, sql, logger) {
        const start = process.hrtime();
        const prom = new Promise((resolve, reject) => {
            db.all(sql, (err, rows) => {
                if (err) {
                    logger === null || logger === void 0 ? void 0 : logger.error(`SqliteQueryUtils.all() failed with error message ${err.message} in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${sql.slice(0, 1000)}`);
                    reject(err.message);
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.info(`Executed SqliteQueryUtils.all() query in ${(0, common_server_1.getDurationMilliseconds)(start)} ms. Query String: ${SqliteQueryUtils.formatQueryString(sql)}`);
                    resolve(rows);
                }
            });
        });
        return common_all_1.ResultAsync.fromPromise(prom, (e) => {
            return this.getSqliteError(e, sql);
        });
    }
    static getSqliteError(errorString, sqlQuery) {
        let type = SqliteError_1.SqliteErrorType.Unknown;
        if (errorString === "SQLITE_CONSTRAINT: FOREIGN KEY constraint failed") {
            type = SqliteError_1.SqliteErrorType.ForeignKeyConstraintViolation;
        }
        else if (errorString.includes("syntax error")) {
            type = SqliteError_1.SqliteErrorType.InvalidQuerySyntax;
        }
        return {
            type,
            query: sqlQuery,
            message: errorString,
            name: type,
        };
    }
    static formatQueryString(sql) {
        const CHAR_LIMIT = 1000;
        if (sql.length <= CHAR_LIMIT) {
            return sql;
        }
        return [sql.slice(0, 500), sql.slice(-500)].join("...");
    }
}
exports.SqliteQueryUtils = SqliteQueryUtils;
//# sourceMappingURL=SqliteQueryUtils.js.map