"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DendronEngineV3Factory = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const path_1 = __importDefault(require("path"));
const vscode_uri_1 = require("vscode-uri");
const DendronEngineV3_1 = require("./DendronEngineV3");
const sqlite_1 = require("./drivers/sqlite");
const store_1 = require("./store");
/**
 * Temp class containing factory methods for DendronEngineV3. This can later be
 * replaced with t-syringe injection.
 */
class DendronEngineV3Factory {
    /**
     * Creates an engine that is configured to use Sqlite as the metadata store.
     * @param param0
     * @returns
     */
    static async createWithSqliteStore({ wsRoot, logger, }) {
        const LOGGER = logger || (0, common_server_1.createLogger)();
        const { error, data: config } = common_server_1.DConfig.readConfigAndApplyLocalOverrideSync(wsRoot);
        if (error) {
            LOGGER.error((0, common_all_1.stringifyError)(error));
        }
        const fileStore = new store_1.NodeJSFileStore();
        // FuseEngine is still used for handling schemas for now
        const fuseEngine = new common_all_1.FuseEngine({
            fuzzThreshold: common_all_1.ConfigUtils.getLookup(config).note.fuzzThreshold,
        });
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        const dbFilePath = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_DB_FILE);
        const dbResult = await sqlite_1.SqliteDbFactory.createInitializedDB(wsRoot, common_all_1.ConfigUtils.getVaults(config), fileStore, dbFilePath, LOGGER);
        if (dbResult.isErr()) {
            logger === null || logger === void 0 ? void 0 : logger.error(`Error in createWithSqliteStore: ${dbResult.error}`);
            throw dbResult.error;
        }
        const sqliteMetadataStore = new sqlite_1.SqliteMetadataStore(dbResult.value, vaults);
        const schemas = await sqliteMetadataStore.initSchema(fileStore, wsRoot, LOGGER);
        const schemaMetadataStore = new common_all_1.SchemaMetadataStore(fuseEngine);
        const schemaStore = new common_all_1.SchemaStore(fileStore, schemaMetadataStore, vscode_uri_1.URI.parse(wsRoot));
        // this step is here because we are still relying one fuse engine on some parts.
        // this can be removed once we completely remove fuse.
        const bulkWriteSchemaOpts = Object.values(schemas).map((schema) => {
            return { key: schema.root.id, schema };
        });
        await schemaStore.bulkWriteMetadata(bulkWriteSchemaOpts);
        return new DendronEngineV3_1.DendronEngineV3({
            wsRoot,
            vaults: common_all_1.ConfigUtils.getVaults(config),
            noteStore: new common_all_1.NoteStore(fileStore, sqliteMetadataStore, vscode_uri_1.URI.file(wsRoot)),
            schemaStore,
            fileStore,
            logger: LOGGER,
            config,
        });
    }
}
exports.DendronEngineV3Factory = DendronEngineV3Factory;
//# sourceMappingURL=DendronEngineV3Factory.js.map