"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const exponential_backoff_with_jitter_1 = __importDefault(require("./exponential_backoff_with_jitter"));
const object_to_query_param_string_1 = __importDefault(require("./object_to_query_param_string"));
const package_version_1 = __importDefault(require("./package_version"));
const fetch_1 = __importDefault(require("./fetch"));
const abort_controller_1 = __importDefault(require("./abort-controller"));
const userAgent = `Airtable.js/${package_version_1.default}`;
function runAction(base, method, path, queryParams, bodyData, callback, numAttempts) {
    const url = `${base._airtable._endpointUrl}/v${base._airtable._apiVersionMajor}/${base._id}${path}?${object_to_query_param_string_1.default(queryParams)}`;
    const headers = {
        authorization: `Bearer ${base._airtable._apiKey}`,
        'x-api-version': base._airtable._apiVersion,
        'x-airtable-application-id': base.getId(),
        'content-type': 'application/json',
    };
    const isBrowser = typeof window !== 'undefined';
    // Some browsers do not allow overriding the user agent.
    // https://github.com/Airtable/airtable.js/issues/52
    if (isBrowser) {
        headers['x-airtable-user-agent'] = userAgent;
    }
    else {
        headers['User-Agent'] = userAgent;
    }
    const controller = new abort_controller_1.default();
    const normalizedMethod = method.toUpperCase();
    const options = {
        method: normalizedMethod,
        headers,
        signal: controller.signal,
    };
    if (bodyData !== null) {
        if (normalizedMethod === 'GET' || normalizedMethod === 'HEAD') {
            console.warn('body argument to runAction are ignored with GET or HEAD requests');
        }
        else {
            options.body = JSON.stringify(bodyData);
        }
    }
    const timeout = setTimeout(() => {
        controller.abort();
    }, base._airtable._requestTimeout);
    fetch_1.default(url, options)
        .then(resp => {
        clearTimeout(timeout);
        if (resp.status === 429 && !base._airtable._noRetryIfRateLimited) {
            const backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts);
            setTimeout(() => {
                runAction(base, method, path, queryParams, bodyData, callback, numAttempts + 1);
            }, backoffDelayMs);
        }
        else {
            resp.json()
                .then(body => {
                const error = base._checkStatusForError(resp.status, body);
                // Ensure Response interface matches interface from
                // `request` Response object
                const r = {};
                Object.keys(resp).forEach(property => {
                    r[property] = resp[property];
                });
                r.body = body;
                r.statusCode = resp.status;
                callback(error, r, body);
            })
                .catch(function () {
                callback(base._checkStatusForError(resp.status));
            });
        }
    })
        .catch(error => {
        clearTimeout(timeout);
        callback(error);
    });
}
module.exports = runAction;
//# sourceMappingURL=run_action.js.map