"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
const deprecate_1 = __importDefault(require("./deprecate"));
const query_1 = __importDefault(require("./query"));
const record_1 = __importDefault(require("./record"));
const callback_to_promise_1 = __importDefault(require("./callback_to_promise"));
class Table {
    constructor(base, tableId, tableName) {
        if (!tableId && !tableName) {
            throw new Error('Table name or table ID is required');
        }
        this._base = base;
        this.id = tableId;
        this.name = tableName;
        // Public API
        this.find = callback_to_promise_1.default(this._findRecordById, this);
        this.select = this._selectRecords.bind(this);
        this.create = callback_to_promise_1.default(this._createRecords, this);
        this.update = callback_to_promise_1.default(this._updateRecords.bind(this, false), this);
        this.replace = callback_to_promise_1.default(this._updateRecords.bind(this, true), this);
        this.destroy = callback_to_promise_1.default(this._destroyRecord, this);
        // Deprecated API
        this.list = deprecate_1.default(this._listRecords.bind(this), 'table.list', 'Airtable: `list()` is deprecated. Use `select()` instead.');
        this.forEach = deprecate_1.default(this._forEachRecord.bind(this), 'table.forEach', 'Airtable: `forEach()` is deprecated. Use `select()` instead.');
    }
    _findRecordById(recordId, done) {
        const record = new record_1.default(this, recordId);
        record.fetch(done);
    }
    _selectRecords(params) {
        if (params === void 0) {
            params = {};
        }
        if (arguments.length > 1) {
            console.warn(`Airtable: \`select\` takes only one parameter, but it was given ${arguments.length} parameters. Use \`eachPage\` or \`firstPage\` to fetch records.`);
        }
        if (isPlainObject_1.default(params)) {
            const validationResults = query_1.default.validateParams(params);
            if (validationResults.errors.length) {
                const formattedErrors = validationResults.errors.map(error => {
                    return `  * ${error}`;
                });
                throw new Error(`Airtable: invalid parameters for \`select\`:\n${formattedErrors.join('\n')}`);
            }
            if (validationResults.ignoredKeys.length) {
                console.warn(`Airtable: the following parameters to \`select\` will be ignored: ${validationResults.ignoredKeys.join(', ')}`);
            }
            return new query_1.default(this, validationResults.validParams);
        }
        else {
            throw new Error('Airtable: the parameter for `select` should be a plain object or undefined.');
        }
    }
    _urlEncodedNameOrId() {
        return this.id || encodeURIComponent(this.name);
    }
    _createRecords(recordsData, optionalParameters, done) {
        const isCreatingMultipleRecords = Array.isArray(recordsData);
        if (!done) {
            done = optionalParameters;
            optionalParameters = {};
        }
        let requestData;
        if (isCreatingMultipleRecords) {
            requestData = { records: recordsData, ...optionalParameters };
        }
        else {
            requestData = { fields: recordsData, ...optionalParameters };
        }
        this._base.runAction('post', `/${this._urlEncodedNameOrId()}/`, {}, requestData, (err, resp, body) => {
            if (err) {
                done(err);
                return;
            }
            let result;
            if (isCreatingMultipleRecords) {
                result = body.records.map(record => {
                    return new record_1.default(this, record.id, record);
                });
            }
            else {
                result = new record_1.default(this, body.id, body);
            }
            done(null, result);
        });
    }
    _updateRecords(isDestructiveUpdate, recordsDataOrRecordId, recordDataOrOptsOrDone, optsOrDone, done) {
        let opts;
        if (Array.isArray(recordsDataOrRecordId)) {
            const recordsData = recordsDataOrRecordId;
            opts = isPlainObject_1.default(recordDataOrOptsOrDone) ? recordDataOrOptsOrDone : {};
            done = (optsOrDone || recordDataOrOptsOrDone);
            const method = isDestructiveUpdate ? 'put' : 'patch';
            const requestData = { records: recordsData, ...opts };
            this._base.runAction(method, `/${this._urlEncodedNameOrId()}/`, {}, requestData, (err, resp, body) => {
                if (err) {
                    done(err);
                    return;
                }
                const result = body.records.map(record => {
                    return new record_1.default(this, record.id, record);
                });
                done(null, result);
            });
        }
        else {
            const recordId = recordsDataOrRecordId;
            const recordData = recordDataOrOptsOrDone;
            opts = isPlainObject_1.default(optsOrDone) ? optsOrDone : {};
            done = (done || optsOrDone);
            const record = new record_1.default(this, recordId);
            if (isDestructiveUpdate) {
                record.putUpdate(recordData, opts, done);
            }
            else {
                record.patchUpdate(recordData, opts, done);
            }
        }
    }
    _destroyRecord(recordIdsOrId, done) {
        if (Array.isArray(recordIdsOrId)) {
            const queryParams = { records: recordIdsOrId };
            this._base.runAction('delete', `/${this._urlEncodedNameOrId()}`, queryParams, null, (err, response, results) => {
                if (err) {
                    done(err);
                    return;
                }
                const records = results.records.map(({ id }) => {
                    return new record_1.default(this, id, null);
                });
                done(null, records);
            });
        }
        else {
            const record = new record_1.default(this, recordIdsOrId);
            record.destroy(done);
        }
    }
    _listRecords(limit, offset, opts, done) {
        if (!done) {
            done = opts;
            opts = {};
        }
        const listRecordsParameters = {
            limit,
            offset,
            ...opts,
        };
        this._base.runAction('get', `/${this._urlEncodedNameOrId()}/`, listRecordsParameters, null, (err, response, results) => {
            if (err) {
                done(err);
                return;
            }
            const records = results.records.map(recordJson => {
                return new record_1.default(this, null, recordJson);
            });
            done(null, records, results.offset);
        });
    }
    _forEachRecord(opts, callback, done) {
        if (arguments.length === 2) {
            done = callback;
            callback = opts;
            opts = {};
        }
        const limit = Table.__recordsPerPageForIteration || 100;
        let offset = null;
        const nextPage = () => {
            this._listRecords(limit, offset, opts, (err, page, newOffset) => {
                if (err) {
                    done(err);
                    return;
                }
                for (let index = 0; index < page.length; index++) {
                    callback(page[index]);
                }
                if (newOffset) {
                    offset = newOffset;
                    nextPage();
                }
                else {
                    done();
                }
            });
        };
        nextPage();
    }
}
module.exports = Table;
//# sourceMappingURL=table.js.map