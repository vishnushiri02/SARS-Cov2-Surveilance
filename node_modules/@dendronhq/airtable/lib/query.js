"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const isFunction_1 = __importDefault(require("lodash/isFunction"));
const keys_1 = __importDefault(require("lodash/keys"));
const record_1 = __importDefault(require("./record"));
const callback_to_promise_1 = __importDefault(require("./callback_to_promise"));
const has_1 = __importDefault(require("./has"));
const query_params_1 = require("./query_params");
/**
 * Builds a query object. Won't fetch until `firstPage` or
 * or `eachPage` is called.
 *
 * Params should be validated prior to being passed to Query
 * with `Query.validateParams`.
 */
class Query {
    constructor(table, params) {
        this._table = table;
        this._params = params;
        this.firstPage = callback_to_promise_1.default(firstPage, this);
        this.eachPage = callback_to_promise_1.default(eachPage, this, 1);
        this.all = callback_to_promise_1.default(all, this);
    }
    /**
     * Validates the parameters for passing to the Query constructor.
     *
     * @params {object} params parameters to validate
     *
     * @return an object with two keys:
     *  validParams: the object that should be passed to the constructor.
     *  ignoredKeys: a list of keys that will be ignored.
     *  errors: a list of error messages.
     */
    static validateParams(params) {
        const validParams = {};
        const ignoredKeys = [];
        const errors = [];
        for (const key of keys_1.default(params)) {
            const value = params[key];
            if (has_1.default(Query.paramValidators, key)) {
                const validator = Query.paramValidators[key];
                const validationResult = validator(value);
                if (validationResult.pass) {
                    validParams[key] = value;
                }
                else {
                    errors.push(validationResult.error);
                }
            }
            else {
                ignoredKeys.push(key);
            }
        }
        return {
            validParams,
            ignoredKeys,
            errors,
        };
    }
}
Query.paramValidators = query_params_1.paramValidators;
/**
 * Fetches the first page of results for the query asynchronously,
 * then calls `done(error, records)`.
 */
function firstPage(done) {
    if (!isFunction_1.default(done)) {
        throw new Error('The first parameter to `firstPage` must be a function');
    }
    this.eachPage(records => {
        done(null, records);
    }, error => {
        done(error, null);
    });
}
/**
 * Fetches each page of results for the query asynchronously.
 *
 * Calls `pageCallback(records, fetchNextPage)` for each
 * page. You must call `fetchNextPage()` to fetch the next page of
 * results.
 *
 * After fetching all pages, or if there's an error, calls
 * `done(error)`.
 */
function eachPage(pageCallback, done) {
    if (!isFunction_1.default(pageCallback)) {
        throw new Error('The first parameter to `eachPage` must be a function');
    }
    if (!isFunction_1.default(done) && done !== void 0) {
        throw new Error('The second parameter to `eachPage` must be a function or undefined');
    }
    const path = `/${this._table._urlEncodedNameOrId()}`;
    const params = { ...this._params };
    const inner = () => {
        this._table._base.runAction('get', path, params, null, (err, response, result) => {
            if (err) {
                done(err, null);
            }
            else {
                let next;
                if (result.offset) {
                    params.offset = result.offset;
                    next = inner;
                }
                else {
                    next = () => {
                        done(null);
                    };
                }
                const records = result.records.map(recordJson => {
                    return new record_1.default(this._table, null, recordJson);
                });
                pageCallback(records, next);
            }
        });
    };
    inner();
}
/**
 * Fetches all pages of results asynchronously. May take a long time.
 */
function all(done) {
    if (!isFunction_1.default(done)) {
        throw new Error('The first parameter to `all` must be a function');
    }
    const allRecords = [];
    this.eachPage((pageRecords, fetchNextPage) => {
        allRecords.push(...pageRecords);
        fetchNextPage();
    }, err => {
        if (err) {
            done(err, null);
        }
        else {
            done(null, allRecords);
        }
    });
}
module.exports = Query;
//# sourceMappingURL=query.js.map