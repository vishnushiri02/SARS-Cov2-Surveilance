"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const get_1 = __importDefault(require("lodash/get"));
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
const keys_1 = __importDefault(require("lodash/keys"));
const fetch_1 = __importDefault(require("./fetch"));
const abort_controller_1 = __importDefault(require("./abort-controller"));
const object_to_query_param_string_1 = __importDefault(require("./object_to_query_param_string"));
const airtable_error_1 = __importDefault(require("./airtable_error"));
const table_1 = __importDefault(require("./table"));
const http_headers_1 = __importDefault(require("./http_headers"));
const run_action_1 = __importDefault(require("./run_action"));
const package_version_1 = __importDefault(require("./package_version"));
const exponential_backoff_with_jitter_1 = __importDefault(require("./exponential_backoff_with_jitter"));
const userAgent = `Airtable.js/${package_version_1.default}`;
class Base {
    constructor(airtable, baseId) {
        this._airtable = airtable;
        this._id = baseId;
    }
    table(tableName) {
        return new table_1.default(this, null, tableName);
    }
    makeRequest(options = {}) {
        var _a;
        const method = get_1.default(options, 'method', 'GET').toUpperCase();
        const url = `${this._airtable._endpointUrl}/v${this._airtable._apiVersionMajor}/${this._id}${get_1.default(options, 'path', '/')}?${object_to_query_param_string_1.default(get_1.default(options, 'qs', {}))}`;
        const controller = new abort_controller_1.default();
        const headers = this._getRequestHeaders(Object.assign({}, this._airtable._customHeaders, (_a = options.headers) !== null && _a !== void 0 ? _a : {}));
        const requestOptions = {
            method,
            headers,
            signal: controller.signal,
        };
        if ('body' in options && _canRequestMethodIncludeBody(method)) {
            requestOptions.body = JSON.stringify(options.body);
        }
        const timeout = setTimeout(() => {
            controller.abort();
        }, this._airtable._requestTimeout);
        return new Promise((resolve, reject) => {
            fetch_1.default(url, requestOptions)
                .then((resp) => {
                clearTimeout(timeout);
                if (resp.status === 429 && !this._airtable._noRetryIfRateLimited) {
                    const numAttempts = get_1.default(options, '_numAttempts', 0);
                    const backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts);
                    setTimeout(() => {
                        const newOptions = {
                            ...options,
                            _numAttempts: numAttempts + 1,
                        };
                        this.makeRequest(newOptions)
                            .then(resolve)
                            .catch(reject);
                    }, backoffDelayMs);
                }
                else {
                    resp.json()
                        .then(body => {
                        const err = this._checkStatusForError(resp.status, body) ||
                            _getErrorForNonObjectBody(resp.status, body);
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve({
                                statusCode: resp.status,
                                headers: resp.headers,
                                body,
                            });
                        }
                    })
                        .catch(() => {
                        const err = _getErrorForNonObjectBody(resp.status);
                        reject(err);
                    });
                }
            })
                .catch(err => {
                clearTimeout(timeout);
                err = new airtable_error_1.default('CONNECTION_ERROR', err.message, null);
                reject(err);
            });
        });
    }
    /**
     * @deprecated This method is deprecated.
     */
    runAction(method, path, queryParams, bodyData, callback) {
        run_action_1.default(this, method, path, queryParams, bodyData, callback, 0);
    }
    _getRequestHeaders(headers) {
        const result = new http_headers_1.default();
        result.set('Authorization', `Bearer ${this._airtable._apiKey}`);
        result.set('User-Agent', userAgent);
        result.set('Content-Type', 'application/json');
        for (const headerKey of keys_1.default(headers)) {
            result.set(headerKey, headers[headerKey]);
        }
        return result.toJSON();
    }
    _checkStatusForError(statusCode, body) {
        const { error = {} } = body !== null && body !== void 0 ? body : { error: {} };
        const { type, message } = error;
        if (statusCode === 401) {
            return new airtable_error_1.default('AUTHENTICATION_REQUIRED', 'You should provide valid api key to perform this operation', statusCode);
        }
        else if (statusCode === 403) {
            return new airtable_error_1.default('NOT_AUTHORIZED', 'You are not authorized to perform this operation', statusCode);
        }
        else if (statusCode === 404) {
            return new airtable_error_1.default('NOT_FOUND', message !== null && message !== void 0 ? message : 'Could not find what you are looking for', statusCode);
        }
        else if (statusCode === 413) {
            return new airtable_error_1.default('REQUEST_TOO_LARGE', 'Request body is too large', statusCode);
        }
        else if (statusCode === 422) {
            return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNPROCESSABLE_ENTITY', message !== null && message !== void 0 ? message : 'The operation cannot be processed', statusCode);
        }
        else if (statusCode === 429) {
            return new airtable_error_1.default('TOO_MANY_REQUESTS', 'You have made too many requests in a short period of time. Please retry your request later', statusCode);
        }
        else if (statusCode === 500) {
            return new airtable_error_1.default('SERVER_ERROR', 'Try again. If the problem persists, contact support.', statusCode);
        }
        else if (statusCode === 503) {
            return new airtable_error_1.default('SERVICE_UNAVAILABLE', 'The service is temporarily unavailable. Please retry shortly.', statusCode);
        }
        else if (statusCode >= 400) {
            return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNEXPECTED_ERROR', message !== null && message !== void 0 ? message : 'An unexpected error occurred', statusCode);
        }
        else {
            return null;
        }
    }
    doCall(tableName) {
        return this.table(tableName);
    }
    getId() {
        return this._id;
    }
    static createFunctor(airtable, baseId) {
        const base = new Base(airtable, baseId);
        const baseFn = (tableName) => {
            return base.doCall(tableName);
        };
        baseFn._base = base;
        baseFn.table = base.table.bind(base);
        baseFn.makeRequest = base.makeRequest.bind(base);
        baseFn.runAction = base.runAction.bind(base);
        baseFn.getId = base.getId.bind(base);
        return baseFn;
    }
}
function _canRequestMethodIncludeBody(method) {
    return method !== 'GET' && method !== 'DELETE';
}
function _getErrorForNonObjectBody(statusCode, body) {
    if (isPlainObject_1.default(body)) {
        return null;
    }
    else {
        return new airtable_error_1.default('UNEXPECTED_ERROR', 'The response from Airtable was invalid JSON. Please try again soon.', statusCode);
    }
}
module.exports = Base;
//# sourceMappingURL=base.js.map