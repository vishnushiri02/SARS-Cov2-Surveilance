"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceController = void 0;
const common_all_1 = require("@dendronhq/common-all");
const engine_server_1 = require("@dendronhq/engine-server");
const core_1 = require("../../core");
const utils_1 = require("../../utils");
const common_server_1 = require("@dendronhq/common-server");
const os_1 = require("os");
class WorkspaceController {
    static instance() {
        if (!WorkspaceController.singleton) {
            WorkspaceController.singleton = new WorkspaceController();
        }
        return WorkspaceController.singleton;
    }
    async init({ uri }) {
        var _a, _b, _c, _d;
        const start = process.hrtime();
        const ctx = "WorkspaceController:init";
        const logger = (0, core_1.getLogger)();
        logger.info({ ctx, msg: "enter", uri });
        common_all_1.ConfigService.instance({
            homeDir: common_all_1.URI.file((0, os_1.homedir)()),
            fileStore: new engine_server_1.NodeJSFileStore(),
        });
        // until we roll out engine v3 as default, we can't remove this line.
        // TODO: remove once `enableEngineV3` is deprecated.
        const config = common_server_1.DConfig.readConfigSync(uri);
        let engine;
        if ((_a = config.dev) === null || _a === void 0 ? void 0 : _a.enableEngineV3) {
            if ((_b = config.dev) === null || _b === void 0 ? void 0 : _b.useSqlite) {
                engine = await engine_server_1.DendronEngineV3Factory.createWithSqliteStore({
                    wsRoot: uri,
                    logger,
                });
            }
            else {
                engine = await engine_server_1.DendronEngineV3.create({
                    wsRoot: uri,
                    logger,
                });
            }
        }
        else {
            engine = engine_server_1.DendronEngineV2.create({
                wsRoot: uri,
                logger,
            });
        }
        // TODO: SQLite doesn't need to do engine.init(), apart from schema setup
        // (which currently doesn't work if Sqlite is enabled)
        if (((_c = config.dev) === null || _c === void 0 ? void 0 : _c.enableEngineV3) && ((_d = config.dev) === null || _d === void 0 ? void 0 : _d.useSqlite)) {
            await (0, utils_1.putWS)({ ws: uri, engine });
            return {};
        }
        else {
            const { data, error } = await engine.init();
            if (error && error.severity === common_all_1.ERROR_SEVERITY.FATAL) {
                logger.error({ ctx, msg: "fatal error initializing notes", error });
                return { data, error };
            }
            await (0, utils_1.putWS)({ ws: uri, engine });
            const duration = (0, common_server_1.getDurationMilliseconds)(start);
            logger.info({ ctx, msg: "finish init", duration, uri, error });
            let error2;
            if (error) {
                error2 = (0, common_all_1.error2PlainObject)(error);
            }
            const payload = {
                error: error2,
                data,
            };
            return payload;
        }
    }
    async sync({ ws }) {
        const engine = await (0, utils_1.getWSEngine)({ ws });
        const notes = await engine.findNotes({ excludeStub: false });
        const configReadResult = await common_all_1.ConfigService.instance().readConfig(common_all_1.URI.file(engine.wsRoot));
        const data = {
            notes: common_all_1.NoteDictsUtils.createNotePropsByIdDict(notes),
            vaults: engine.vaults,
            wsRoot: engine.wsRoot,
        };
        if (configReadResult.isErr()) {
            return {
                data,
                error: configReadResult.error,
            };
        }
        data.config = configReadResult.value;
        return {
            data,
        };
    }
}
exports.WorkspaceController = WorkspaceController;
//# sourceMappingURL=index.js.map