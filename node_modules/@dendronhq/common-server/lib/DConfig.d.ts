import { CleanDendronPublishingConfig, DeepPartial, DendronPublishingConfig, RespV3, RespWithOptError, DendronConfig } from "@dendronhq/common-all";
export declare enum LocalConfigScope {
    WORKSPACE = "WORKSPACE",
    GLOBAL = "GLOBAL"
}
/**
 * @deprecated
 */
export declare class DConfig {
    /**
     * @deprecated
     * Use {@link ConfigService.configPath} instead
     * e.g.) const configPath = ConfigService.instance().configPath(URI.file(wsRoot))
     */
    static configPath(configRoot: string): string;
    /**
     * @deprecated
     * use {@link ConfigService.configOverridePath} instead
     * e.g.) const overridePath = ConfigService.instance().configOverridePath(URI.file(wsRoot), "workspace")
     */
    static configOverridePath(wsRoot: string, scope: LocalConfigScope): string;
    /**
     * @deprecated
     * This will be moved to a more suitable location in the near future
     */
    static getSiteIndex(sconfig: DendronPublishingConfig): string;
    /**
     * @deprecated
     * fill in defaults
     * This will be moved to a more suitable location in the near future
     */
    static cleanPublishingConfig(config: DendronPublishingConfig): CleanDendronPublishingConfig;
    /**
     * @deprecated
     * This will be moved to a more suitable location in the near future
     */
    static setCleanPublishingConfig(opts: {
        config: DendronConfig;
        cleanConfig: DendronPublishingConfig;
    }): void;
    /**
     * @deprecated should be removed when we roll out engine v3
     *
     * Use {@link ConfigService.searchOverride} instead
     * e.g.)
     * searchOverrideResult = await ConfigService.instance().searchOverride(URI.file(wsRoot))
     *
     * See if a local config file is present
     */
    static searchLocalConfigSync(wsRoot: string): RespV3<DendronConfig>;
    /**
     * @deprecated should be removed when we roll out engine v3
     *
     * Use {@link ConfigService.readConfig} instead
     * e.g.)
     * const readResult = await ConfigService.instance().readConfig(URI.file(wsRoot), { applyOverride: false });
     *
     * Read configuration
     * @param wsRoot
     * @param useCache: If true, read from cache instead of file system
     * @returns
     */
    static readConfigSync(wsRoot: string, useCache?: boolean): DendronConfig;
    /**
     * @deprecated should be removed when we roll out engine v3
     *
     * Use {@link ConfigService.readConfig} instead
     * e.g.)
     * const readResult = await ConfigService.instance().readConfig(URI.file(wsRoot));
     *
     * Read config and merge with local config
     * @param wsRoot
     * @param useCache: If true, read from cache instead of file system
     * @returns
     */
    static readConfigAndApplyLocalOverrideSync(wsRoot: string, useCache?: boolean): RespWithOptError<DendronConfig>;
    /**
     * @deprecated should be removed when we roll out engine v3
     *
     * Use {@link ConfigUtils.validateLocalConfig} instead
     *
     * Sanity check local config properties
     */
    static validateLocalConfig({ config, }: {
        config: DeepPartial<DendronConfig>;
    }): RespV3<boolean>;
    /**
     * @deprecated TODO: move to ConfigService
     * Create a backup of dendron.yml with an optional custom infix string.
     * e.g.) createBackup(wsRoot, "foo") will result in a backup file name
     * `dendron.yyyy.MM.dd.HHmmssS.foo.yml`
     * @param wsRoot workspace root
     * @param infix custom string used in the backup name
     * ^fd66z8uiuczz
     */
    static createBackup(wsRoot: string, infix?: string): Promise<string>;
}
