"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaParserV2 = exports.ParserBaseV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const filesv2_1 = require("./filesv2");
const logger_1 = require("./logger");
const ajv_1 = __importDefault(require("ajv"));
const ajv_errors_1 = __importDefault(require("ajv-errors"));
class AJVProvider {
    static getAjv() {
        if (this.ajv === undefined) {
            this.ajv = new ajv_1.default({ allErrors: true, allowUnionTypes: true });
            // Allows custom error messages to be specified within the ajv-schema definition.
            (0, ajv_errors_1.default)(this.ajv);
        }
        return this.ajv;
    }
}
let _LOGGER;
function getLogger() {
    if (!_LOGGER) {
        _LOGGER = (0, logger_1.createLogger)();
    }
    return _LOGGER;
}
class ParserBaseV2 {
    constructor(opts) {
        this.opts = opts;
    }
    get logger() {
        return this.opts.logger;
    }
}
exports.ParserBaseV2 = ParserBaseV2;
const DEFAULT_LOG_CTX = "parsingSchemas";
async function getSchemasFromImport(imports, opts) {
    const vpath = (0, filesv2_1.vault2Path)({ vault: opts.root, wsRoot: opts.wsRoot });
    let schemaModulesFromImport = [];
    await Promise.all(lodash_1.default.map(imports, async (ent) => {
        const fpath = path_1.default.join(vpath, ent + ".schema.yml");
        schemaModulesFromImport.push(await (0, filesv2_1.file2Schema)(fpath, opts.wsRoot));
    }));
    const schemaPropsFromImport = schemaModulesFromImport.flatMap((mod) => {
        const domain = mod.fname;
        return lodash_1.default.values(mod.schemas).map((ent) => {
            ent.data.pattern = ent.data.pattern || ent.id;
            ent.id = `${domain}.${ent.id}`;
            ent.fname = opts.fname;
            ent.parent = null;
            ent.children = ent.children.map((ent) => `${domain}.${ent}`);
            ent.vault = opts.root;
            return ent;
        });
    });
    getLogger().debug({ ctx: DEFAULT_LOG_CTX, schemaPropsFromImport });
    return schemaPropsFromImport;
}
/** AJV (https://ajv.js.org/) schemas for schema validation. */
const AJV_SCHEMAS = {
    SCHEMA_OBJ: {
        type: "object",
        properties: {
            id: { type: "string" },
            desc: { type: "string" },
            parent: { type: "string" },
            namespace: { type: "boolean" },
            children: { type: "array" },
            pattern: { type: "string" },
            title: { type: "string" },
            fname: { type: "string" },
            template: { type: ["string", "object"] },
            vault: { type: "object" },
            isIdAutoGenerated: { type: "boolean" },
        },
        required: [],
        additionalProperties: {
            not: true,
            errorMessage: "Detected invalid property ${0#}",
        },
        errorMessage: {
            properties: {
                id: "Id should be unique string value, found value='${/id}'",
                desc: "Description should be string value, found value='${/desc}'",
                parent: "Parent should be id of the parent schema, found value='${/parent}'",
                namespace: "Namespace should be a boolean flag, found value='${/namespace}'",
                pattern: "Pattern should be a string value, (preferably surrounded by quotes), found value='${/pattern}'",
                title: "Title should be a string value, found value='${/title}'",
                template: "Template should either be string id to the note OR typed template object, found value='${/template}'",
            },
        },
    },
};
class SchemaParserV2 extends ParserBaseV2 {
    static async parseRaw(schemaOpts, opts) {
        const version = lodash_1.default.isArray(schemaOpts) ? 0 : 1;
        if (version > 0) {
            return SchemaParserV2.parseSchemaModuleOpts(schemaOpts, opts);
        }
        else {
            // TODO: legacy
            const schemaDict = {};
            schemaOpts.map((ent) => {
                const schema = common_all_1.SchemaUtils.createFromSchemaOpts(ent);
                schemaDict[schema.id] = schema;
            });
            const maybeRoot = lodash_1.default.find(lodash_1.default.values(schemaDict), {
                parent: "root",
            });
            return {
                version: 0,
                root: maybeRoot,
                schemas: schemaDict,
                fname: opts.fname,
                vault: opts.root,
            };
        }
    }
    static noInlineChildren(ent) {
        return (!ent.children || ent.children.length === 0 || lodash_1.default.isString(ent.children[0]));
    }
    static validateTopSchemasHaveIds(schemas) {
        schemas.forEach((schema) => {
            if (lodash_1.default.isUndefined(schema.id)) {
                throw common_all_1.ErrorFactory.createSchemaValidationError({
                    message: `Schema id is missing from top level schema. Schema at fault: '${JSON.stringify(schema)}'`,
                });
            }
        });
    }
    static getSchemasFromFile(schemas, vault) {
        const collector = [];
        this.validateTopSchemasHaveIds(schemas);
        schemas.forEach((ent) => {
            if (this.noInlineChildren(ent)) {
                // Means we are dealing with non-inline schema and can just collect
                // the parsed value.
                collector.push(this.createFromSchemaOpts({ ...ent, vault }));
            }
            else {
                // When we are dealing with inline children we need to process/collect
                // the children bottom up from the inline tree and replace the children
                // object with collected/generated ids of the inline children.
                ent.children = this.processChildren(ent.children, collector, vault);
                // No all the entity children objects are collected and they have
                // been replaced with identifiers we can collect the root element itself.
                collector.push(this.createFromSchemaOpts({ ...ent, vault }));
            }
        });
        getLogger().debug({ ctx: DEFAULT_LOG_CTX, schemaPropsFromFile: collector });
        return collector;
    }
    static createFromSchemaRaw(opts) {
        this.validateSchemaOptsPreCreation(opts);
        return common_all_1.SchemaUtils.createFromSchemaRaw(opts);
    }
    static createFromSchemaOpts(opts) {
        this.validateSchemaOptsPreCreation(opts);
        return common_all_1.SchemaUtils.createFromSchemaOpts(opts);
    }
    static validateSchemaOptsPreCreation(opts) {
        var _a;
        const validator = AJVProvider.getAjv().compile(AJV_SCHEMAS.SCHEMA_OBJ);
        const isValid = validator(opts);
        if (!isValid) {
            let message = "";
            (_a = validator.errors) === null || _a === void 0 ? void 0 : _a.forEach((err) => {
                // When our custom AJV error is met the keyword of error will be set to
                // 'errorMessage' Hence in that case we expect the formatted message to
                // contain good enough description for the user.
                // If we encounter the non custom message then as backup we will
                // dump entire JSON error object as reason (which will be not be as pretty
                // but at least communicate the issue to the user).
                if (err.keyword === "errorMessage") {
                    message += err.message + " ";
                }
                else {
                    message += JSON.stringify(err) + " ";
                }
            });
            throw common_all_1.ErrorFactory.createSchemaValidationError({
                message: message,
            });
        }
    }
    static processChildren(children, collector, vault) {
        if (!children) {
            return [];
        }
        return children.map((child) => {
            // To process the node we need all its children to already be processed
            // hence call process children recursively to process the graph from bottom up.
            child.children = this.processChildren(child.children, collector, vault);
            this.setIdIfMissing(child);
            collector.push(this.createFromSchemaRaw({ ...child, vault }));
            return child.id;
        });
    }
    /**
     * Ids are optional for inline schemas hence if there isn't an id
     * we will generate the identifier. */
    static setIdIfMissing(ent) {
        if (!ent.id) {
            // When id is missing than we must have a pattern for the schema.
            if (!ent.pattern) {
                throw common_all_1.ErrorFactory.createSchemaValidationError({
                    message: `Pattern is missing in schema without id. Schema at fault='${JSON.stringify(ent)}'`,
                });
            }
            ent.isIdAutoGenerated = true;
            ent.id = (0, common_all_1.genUUID)();
        }
    }
    static async parseSchemaModuleOpts(schemaModuleProps, opts) {
        const { imports, schemas, version } = schemaModuleProps;
        const { fname, root } = opts;
        getLogger().info({ ctx: DEFAULT_LOG_CTX, fname, root, imports });
        const schemasAll = [
            ...(await getSchemasFromImport(imports, opts)),
            ...this.getSchemasFromFile(schemas, root),
        ];
        const schemasDict = {};
        schemasAll.forEach((ent) => {
            schemasDict[ent.id] = ent;
        });
        const addConnections = (parent) => {
            lodash_1.default.forEach(parent.children, (childId) => {
                const child = schemasDict[childId];
                if (child) {
                    if (child.parent === null) {
                        // Child does not have a parent pointers hence we can linkup the parent child as is.
                        common_all_1.DNodeUtils.addChild(parent, child);
                        addConnections(child);
                    }
                    else {
                        // Child already contains a parent pointer hence we need to create a schema clone
                        // otherwise we would end up writing over the already existing parent pointer.
                        const childClone = lodash_1.default.cloneDeep(child);
                        // We use a dictionary hence we need to generate a brand new identifier for our clone.
                        childClone.id = `${childId}_${(0, common_all_1.genUUID)()}`;
                        schemasDict[childClone.id] = childClone;
                        // When it comes to schemas we often use the id as a matching pattern
                        // unless there is a pattern explicitly specified. Since we created a randomized
                        // identifier the id of our clone no longer can be used for pattern matching.
                        // Hence if there isn't a pattern we will set the pattern to match original id.
                        if (childClone.data === undefined ||
                            childClone.data.pattern === undefined) {
                            lodash_1.default.set(childClone, "data.pattern", childId);
                        }
                        // Parent likely already has a reference to the original child identifier
                        // so for us to be able to add new generated child id without creating duplicates
                        // in the parent we will need to take out the original child id.
                        if (parent.children.includes(childId)) {
                            parent.children = parent.children.filter((ch) => ch !== childId);
                        }
                        // Finally we can create the connection between parent and the child clone.
                        common_all_1.DNodeUtils.addChild(parent, childClone);
                        addConnections(childClone);
                    }
                }
                else {
                    throw new common_all_1.DendronError({
                        status: common_all_1.ERROR_STATUS.MISSING_SCHEMA,
                        message: JSON.stringify({ parent, missingChild: childId }),
                    });
                }
            });
        };
        // add parent relationship
        const rootModule = common_all_1.SchemaUtils.getModuleRoot(schemaModuleProps);
        addConnections(rootModule);
        return {
            version,
            imports,
            root: rootModule,
            schemas: schemasDict,
            fname,
            vault: root,
        };
    }
}
exports.SchemaParserV2 = SchemaParserV2;
//# sourceMappingURL=parser.js.map